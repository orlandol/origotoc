
%source {
  // begin strnlen copied from packcc.c source file, as a workaround for TinyCC
  static size_t strnlen(const char *str, size_t maxlen) {
    size_t i;
    for( i = 0; (i < maxlen) && str[i]; i++ ) {
    };
    return i;
  }
  // end

/*
  static const char *dbg_str[] = { "Evaluating rule", "Matched rule", "Abandoning rule" };
  #define PCC_DEBUG(event, rule, level, pos, buffer, length) \
    if( (event == 0) || (event == 2) ) {\
      fprintf(stderr, "%*s%s %s @%d [%.*s]\n", level * 2, "", dbg_str[event], rule, pos, length, buffer);\
    }
*/
}

source_header <-
  _ program_declaration (toplevel)* run_block (toplevel)* _ EOF {
  }

program_declaration <- 'program' _ <IDENT> _ {
  printf( "// %s\n", $0 );
  printf( "#include <stdbool.h>\n\n"
  "typedef __int8 int8;\n"
  "typedef __int16 int16;\n"
  "typedef __int32 int32;\n"
  "typedef __int32 int32;\n\n"
  "typedef __uint8 uint8;\n"
  "typedef __uint16 uint16;\n"
  "typedef __uint32 uint32;\n"
  "typedef __uint32 uint32;\n\n"
  "typedef size_t fsize;\n\n"
  "typedef size_t size;\n\n" );
}

toplevel <-
  enum_declaration _ (enum_field_declaration)* _ 'end' _ {
    printf( "};\n" );
  }
/ 'type' _ <TYPESPEC> _ <IDENT> _ '=' _ <CONSTEXPR> _ {
    printf( "type [%s][%s] = [%s]\n", $1, $2, $3 );
  }
/ 'type' _ <TYPESPEC> _ <IDENT> _ {
    printf( "type [%s][%s]\n", $4, $5 );
  }
/ type_union_declaration _ '(' _ (inline_union_declaration)* _ ')' _ <IDENT> _ {
    printf( "] %s\n", $6 );
  }

enum_declaration <-
  'enum' _ <BASETYPE> _ <IDENT> _ {
    printf( "enum [%s][%s]\n", $1, $2 );
  }
/ 'enum' _ <IDENT> _ {
    printf( "enum [%s]\n", $3 );
  }

enum_field_declaration <-
  &'end'
/ <IDENT> _ '=' _ <CONSTEXPR> _ {
    printf( "  [%s] = [%s]\n", $1, $2 );
  }
/ <IDENT> _ ',' _ {
    printf( "  [%s],\n", $3 );
  }
/ <IDENT> _ {
    printf( "  [%s]\n", $4 );
  }

type_union_declaration <-
  'type' _ 'union' _ {
    printf( "type union[" );
  }

inline_union_declaration <-
  <TYPESPEC> _ ',' _ {
    printf( "[%s], ", $1 );
  }
/ <TYPESPEC> _ {
    printf( "[%s]", $2 );
  }

local_var_block <- 'var' _ (local_var_declaration)* _ 'end' _ {
}

local_var_declaration <-
  &'end'
/ <TYPESPEC> _ <IDENT> _ '=' _ <EXPR> _ {
    printf( "  [%s][%s] = [%s]\n", $1, $2, $3 );
  }
/ <TYPESPEC> _ <IDENT> _ {
    printf( "  [%s][%s]\n", $4, $5 );
  }

run_block <-
  run _ (local_var_block)* _ (statement)* _ 'end' _ {
    printf( "end\n" );
  }

run <- 'run' _ {
  printf( "run\n" );
}

statement <-
  &'end'
/ if_statement _ 'then' _ statement _
/ 'goto' _ <IDENT> _ {
    printf( "  goto [%s]\n", $1 );
  }
/ 'exit' _ '(' _ <EXPR> _ ')' _ {
    printf( "  exit( %s )\n", $2 );
  }
/ <IDENT>':' _ {
    printf( "%s:", $3 );
  }

if_statement <-
  'if' _ <CONDITION> {
    printf( "  if [%s]\n", $1 );
  }

_ <- (SPACE / EOL / MLCOMMENT)*

SPACE <- ' ' / '\t'

EOL <- '\r\n' / '\n' / '\r'

EOF <- !.

MLCOMMENT <- '/*' ( (!'*/' .)* '*/')*

IDENT <- [_a-zA-Z][_a-zA-Z0-9]*

INTNUM <- [0-9]+

BASETYPE <-
  ('int' / 'int8' / 'int16' / 'int32')
/ ('uint' / 'uint8' / 'uint16' / 'uint32')
/ 'bool'
/ 'char'

SIMPLETYPE <- BASETYPE / IDENT

TYPESPEC <- <[@#]?> _ <SIMPLETYPE> _ ('[' _ <CONSTEXPR> _ ']')? _

CONDITION <- IDENT / INTNUM

EXPR <- IDENT / INTNUM

CONSTEXPR <- EXPR

%%

int main( int argc, char* argv[] ) {
  pcc_context_t *ctx = pcc_create(NULL);

  while( pcc_parse(ctx, NULL) ) {
  };

  pcc_destroy( ctx );

  return 0;
}
