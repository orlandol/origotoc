
%source {
#include <ctype.h>

  char rootIdent[256] = {}; ///TODO: Use auxiliary instead

  // begin strnlen copied from packcc.c source file, as a workaround for TinyCC
  static size_t strnlen(const char *str, size_t maxlen) {
    size_t i;
    for( i = 0; (i < maxlen) && str[i]; i++ ) {
    };
    return i;
  }
  // end

/*
  static const char *dbg_str[] = { "Evaluating rule", "Matched rule", "Abandoning rule" };
  #define PCC_DEBUG(event, rule, level, pos, buffer, length) \
      fprintf(stderr, "%*s%s %s @%d [%.*s]\n", level * 2, "", dbg_str[event], rule, pos, length, buffer);
*/

  int TranslateTypeSpec( const char* typeSpec, size_t* arrayDim ) {
    size_t tspecPos = 0;
    char ptrCh = '\0';
    char simpleType[256] = {};
    size_t simpleTypeLen = 0;
    size_t tmpDim = 0;

    if( !(typeSpec && arrayDim) ) {
      return 0;
    }

    // Process pointer type
    while( isspace(typeSpec[tspecPos]) ) {
      tspecPos++;
    }
    if( typeSpec[tspecPos] == '\0' ) {
      return 0;
    }
    if( typeSpec[tspecPos] == '@' ) {
      ptrCh = '*';
      tspecPos++;
    }

    // Process simple type
    while( isspace(typeSpec[tspecPos]) ) {
      tspecPos++;
    }
    if( typeSpec[tspecPos] == '\0' ) {
      return 0;
    }
    while( isalnum(typeSpec[tspecPos]) ) {
      if( simpleTypeLen < sizeof(simpleTypeLen-1) ) {
        simpleType[simpleTypeLen] = typeSpec[tspecPos];
        simpleTypeLen++;
      }
      tspecPos++;
    }
    simpleType[simpleTypeLen] = '\0';

    // Process array dimension
    while( isspace(typeSpec[tspecPos]) ) {
      tspecPos++;
    }
    if( typeSpec[tspecPos] == '[' ) {
      tspecPos++;
      while( isspace(typeSpec[tspecPos]) ) {
        tspecPos++;
      }
      while( isdigit(typeSpec[tspecPos]) ) {
        tmpDim = (tmpDim * 10) + (typeSpec[tspecPos] - '0');
        tspecPos++;
      }
      while( isspace(typeSpec[tspecPos]) ) {
        tspecPos++;
      }
      if( typeSpec[tspecPos] != ']' ) {
        return 0;
      }
      tspecPos++;
      *arrayDim = tmpDim;
    }

		// Output C declaration
    if( ptrCh ) {
      printf( "%s%c ", simpleType, ptrCh );
    } else {
      printf( "%s ", simpleType );
    }

    return -1;
  }
}

## Begin program header
program_header <-
  _ program_begin _ declaration* _ run_block _ declaration* _ EOF {
  }

program_begin <-
  'program' _ <IDENT> {
    printf( "// program %s\n\n", $1 );
    printf(
      "#include <stdbool.h>\n"
      "#include <stdint.h>\n"
      "#include <stdlib.h>\n"
      "\n"
      "  typedef unsigned uint;\n"
      "  typedef int8_t int8;\n"
      "  typedef int16_t int16;\n"
      "  typedef int32_t int32;\n"
      "  typedef int32_t int32;\n"
      "\n"
      "  typedef uint8_t uint8;\n"
      "  typedef uint16_t uint16;\n"
      "  typedef uint32_t uint32;\n"
      "  typedef uint32_t uint32;\n"
      "\n"
      "  typedef uint64_t fsize;\n"
      "\n"
      "  typedef unsigned size;\n"
      "\n"
      "  int argc;\n"
      "  char** argv = NULL;\n"
      "\n"
    );
  }
# End program header

## Begin top level grammar
declaration <-
  declare_enum
/ declare_union
#/ declare_struct
/ _ declare_type
#/ declare_const
#/ declare_global_var
#/ declare_func_prototype
#/ declare_func_import
#/ declare_object
#/ declare_object_new
#/ declare_object_free
#/ declare_interface
#/ declare_method
# End top level grammar

## Begin local variable declaration grammar
declare_local_var <-
  'var' (_ declare_local)* _ 'end'

declare_local <-
  &'end'
/ <TYPESPEC> _ <IDENT> _ {
  }

# End local variable declaration grammar

## Begin enum declaration grammar
declare_enum <-
  declare_enum_begin _ declare_enum_field* _ 'end' {
    ///TODO: Generate structure and constant from queue
    printf(
      "  // end\n"
      "  }\n"
      "\n"
    );
  }

declare_enum_begin <-
  'enum' _ <IDENT> {
    ///TODO: Queue declarations
    $$ = 0;
    printf( "  // %s\n", $0 );
    printf( "  enum {\n", $1 );
  }

declare_enum_field <-
  &'end'
/ <IDENT> _ '=' _ <CONSTEXPR> _ {
    $$ = atoi($2);
    printf( "    %s = %s // %i\n", $1, $2, $$++ );
  }
/ <IDENT> _ {
    printf( "    %s // %i\n", $3, $$++ );
  }
# End enum declaration grammar

## Begin union declaration grammar
declare_union <-
  _ declare_union_begin (_ declare_union_field)* _ 'end' {
    printf( "  // end\n" );
    printf( "  } %s;\n\n", rootIdent );
  }

declare_union_begin <-
  'union' _ <IDENT> {
    strcpy( rootIdent, $1 );

    printf( "  // %s\n", $0 );
    printf( "  typedef union %s {\n", rootIdent );
  }

declare_union_field <-
  &'end'
/ <TYPESPEC> _ <IDENT> {
    printf( "    " );

    size_t arrayDim = 0;
    TranslateTypeSpec( (char*)$1, &arrayDim );

    if( arrayDim ) {
      printf( "%s[%i];", $2, arrayDim );
    } else {
      printf( "%s;", $2 );
    }
    printf( " // %s\n", $0 );
  }
# End union declaration grammar

## Begin type declaration grammar
declare_type <-
  'type' _ <TYPESPEC> _ <IDENT> {
    printf( "  // %s\n", $0 );

    printf( "  typedef " );

    size_t arrayDim = 0;
    TranslateTypeSpec( (char*)$1, &arrayDim );

    if( arrayDim ) {
      printf( "%s[%i];\n\n", $2, arrayDim );
    } else {
      printf( "%s;\n\n", $2 );
    }
  }
# End type declaration grammar

## Begin run block grammar
run_block <-
  run_begin _ declare_local_var* _ STATEMENT* _ 'end' {
    printf(
      "\n"
      "  // end\n"
      "  return 0;\n"
      "}\n"
    );
  }

run_begin <-
  _ 'run' {
    printf(
      "// run\n"
      "int main( int paramArgc, char* paramArgv[] ) {\n"
      "  argc = paramArgc;\n"
      "  argv = paramArgv;\n\n"
    );
  }
# End run block grammar

## Begin statement grammar
STATEMENT <-
  &'end'
/ # Function/Method call
  _ <QUALIFIEDIDENT _ '(' _ (EXPR (_ ',' _ EXPR)*)* _ ')'> _ {
    printf( "  %s;\n", $1 );
  }
/ # Variable expression assignment
  _ <QUALIFIEDIDENT _ ASSIGNOP _ EXPR> _ {
    printf( "  %s;\n", $2 );
  }
/ # Pointer address assignment expression
  _ <'@'QUALIFIEDIDENT _ ASSIGNOP _ EXPR> _ {
    printf( "  %s;\n", $3 );
  }
# End statement grammar

## Begin constant expression gramamr
CONSTEXPR <-
  CONSTSUBEXPR

CONSTSUBEXPR <-
  CONSTLOGICALOR

CONSTLOGICALOR <-
  CONSTLOGICALOR _ '||' _ CONSTLOGICALAND
/ CONSTLOGICALAND

CONSTLOGICALAND <-
  CONSTLOGICALAND _ '&&' _ CONSTBITOR
/ CONSTBITOR

CONSTBITOR <-
  CONSTBITOR _ '|' _ CONSTBITXOR
/ CONSTBITXOR

CONSTBITXOR <-
  CONSTBITXOR _ '^' _ CONSTBITAND
/ CONSTBITAND

CONSTBITAND <-
  CONSTBITAND _ '&' _ CONSTEQUALS
/ CONSTEQUALS

CONSTEQUALS <-
  CONSTEQUALS _ ('==' / '!=') _ CONSTCOMPARE
/ CONSTCOMPARE

CONSTCOMPARE <-
  CONSTCOMPARE _ ('<' / '<=' / '>' / '>=') _ CONSTSHIFT
/ CONSTSHIFT

CONSTSHIFT <-
  CONSTSHIFT _ ('<<' / '>>') _ CONSTTERM
/ CONSTTERM

CONSTTERM <-
  CONSTTERM _ ('+' / '-') _ CONSTFACTOR
/ CONSTFACTOR

CONSTFACTOR <-
  CONSTFACTOR _ ('*' / '/' / '%') _ CONSTUNARYOP
/ CONSTUNARYOP

CONSTUNARYOP <-
  ('+' / '-' / '~' / '!') _ CONSTUNARYOP
/ CONSTOPERAND

CONSTOPERAND <-
  INTNUM
/ QUALIFIEDIDENT _ '(' _ SUBEXPR _ ')'
/ (('++' / '--' / '@') _)? QUALIFIEDIDENT (_ ('++'/'--'))?
/ '(' _ CONSTSUBEXPR _ ')'
# End constant expression grammar

## Begin expression grammar
EXPR <-
  SUBEXPR

SUBEXPR <-
  LOGICALOR

LOGICALOR <-
  LOGICALOR _ '||' _ LOGICALAND
/ LOGICALAND

LOGICALAND <-
  LOGICALAND _ '&&' _ BITOR
/ BITOR

BITOR <-
  BITOR _ '|' _ BITXOR
/ BITXOR

BITXOR <-
  BITXOR _ '^' _ BITAND
/ BITAND

BITAND <-
  BITAND _ '&' _ EQUALS
/ EQUALS

EQUALS <-
  EQUALS _ ('==' / '!=') _ COMPARE
/ COMPARE

COMPARE <-
  COMPARE _ ('<' / '<=' / '>' / '>=') _ SHIFT
/ SHIFT

SHIFT <-
  SHIFT _ ('<<' / '>>') _ TERM
/ TERM

TERM <-
  TERM _ ('+' / '-') _ FACTOR
/ FACTOR

FACTOR <-
  FACTOR _ ('*' / '/' / '%') _ UNARYOP
/ UNARYOP

UNARYOP <-
  ('+' / '-' / '~' / '!') _ UNARYOP
/ OPERAND

OPERAND <-
  INTNUM
/ QUALIFIEDIDENT _ '(' _ SUBEXPR _ ')'
/ (('++' / '--' / '@') _)? QUALIFIEDIDENT (_ ('++'/'--'))?
/ '(' _ SUBEXPR _ ')'
# End expression grammar

## Begin type definitions
TYPESPEC <-
  [@]? _ SIMPLETYPE _ ('[' _ <CONSTEXPR> _ ']')?

SIMPLETYPE <-
  BASETYPE
/ IDENT

BASETYPE <-
  'int' / 'int8' / 'int16' / 'int32' /
  'uint' / 'uint8' / 'uint16' / 'uint32' / 'uint64' /
  'fsize' / 'size' /
  'bool' / 'char'
# End type definitions

## Begin tokenizer definitions
EOF <- !.

_ <- SPACE

SPACE <- [ \t\r\n]*

ASSIGNOP <-
  '=' / '+=' / '-=' / '*=' / '/=' / '%='
  / '<<=' / '>>=' / '&=' / '^=' / '|='

INTNUM <- [0-9]+
IDENT <- [_a-zA-Z][_a-zA-Z0-9]*
QUALIFIEDIDENT <- IDENT (_ '.' _ IDENT)*
# End tokenizer definitions

%%

int main( int argc, char* argv[] ) {
  pcc_context_t *ctx = pcc_create(NULL);

  while( pcc_parse(ctx, NULL) ) {
  };

  pcc_destroy( ctx );

  return 0;
}
