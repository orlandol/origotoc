
%source {
  // begin strnlen copied from packcc.c source file, as a workaround for TinyCC
  static size_t strnlen(const char *str, size_t maxlen) {
    size_t i;
    for( i = 0; (i < maxlen) && str[i]; i++ ) {
    };
    return i;
  }
  // end

/*
  static const char *dbg_str[] = { "Evaluating rule", "Matched rule", "Abandoning rule" };
  #define PCC_DEBUG(event, rule, level, pos, buffer, length) \
    fprintf(stderr, "%*s%s %s @%d [%.*s]\n", level * 2, "", dbg_str[event], rule, pos, length, buffer);
*/
}

source_header <-
  (_'program' _ <IDENT> _ (toplevel)*) _ run _ (toplevel)* _ EOF ~ {
    PCC_ERROR();
  }

toplevel <-
  _ 'const'

run <-
  _ 'run' _ (statement)* _ 'end' ~ {
    PCC_ERROR();
  }

statement <-
  _ 'if' {
    printf( "  if\n" );
  }
/ _ 'goto' _ <IDENT> {
    printf( "  goto [%s]\n", $1 );
  }
/ _ 'exit' _ '(' _ <INTNUM> _ ')' {
    printf( "  exit( %s )\n", $2 );
  }

_ <- (SPACE / EOL / MLCOMMENT)*

SPACE <- ' ' / '\t'

EOL <- '\r\n' / '\n' / '\r'

EOF <- !.

MLCOMMENT <- '/*' ( (!'*/' .)* '*/')*

IDENT <- [_a-zA-Z][_a-zA-Z0-9]*

INTNUM <- [0-9]+

%%

int main( int argc, char* argv[] ) {
  pcc_context_t *ctx = pcc_create(NULL);

  while( pcc_parse(ctx, NULL) ) {
  };

  pcc_destroy( ctx );

  return 0;
}
