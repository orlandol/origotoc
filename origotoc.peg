
%source {
  // begin strnlen copied from packcc.c source file, as a workaround for TinyCC
  static size_t strnlen(const char *str, size_t maxlen) {
    size_t i;
    for( i = 0; (i < maxlen) && str[i]; i++ ) {
    };
    return i;
  }
  // end

/*
  static const char *dbg_str[] = { "Evaluating rule", "Matched rule", "Abandoning rule" };
  #define PCC_DEBUG(event, rule, level, pos, buffer, length) \
      fprintf(stderr, "%*s%s %s @%d [%.*s]\n", level * 2, "", dbg_str[event], rule, pos, length, buffer);
*/
}

# Begin program header
program_header <-
  _ program_begin _ declaration* _ run_block _ declaration* _ EOF {
  }

program_begin <-
  'program' _ <IDENT> {
    printf( "// program %s\n\n", $1 );
    printf(
      "#include <stdbool.h>\n"
      "#include <stdint.h>\n"
      "#include <stdlib.h>\n"
      "\n"
      "  typedef unsigned uint;\n"
      "  typedef int8_t int8;\n"
      "  typedef int16_t int16;\n"
      "  typedef int32_t int32;\n"
      "  typedef int32_t int32;\n"
      "\n"
      "  typedef uint8_t uint8;\n"
      "  typedef uint16_t uint16;\n"
      "  typedef uint32_t uint32;\n"
      "  typedef uint32_t uint32;\n"
      "\n"
      "  typedef uint64_t fsize;\n"
      "\n"
      "  typedef unsigned size;\n"
      "\n"
      "  int argc;\n"
      "  char** argv = NULL;\n"
      "\n"
    );
  }
# End program header

# Begin top level grammar
declaration <-
  declare_enum
#/ declare_union
#/ declare_struct
/ declare_type
#/ declare_const
#/ declare_var
#/ declare_func_prototype
#/ declare_func_import
#/ declare_object
#/ declare_object_new
#/ declare_object_free
#/ declare_interface
#/ declare_method
# End top level grammar

# Begin local variable declaration grammar
declare_local_var <-
  'var' _ 'end'
# End local variable declaration grammar

# Begin enum declaration grammar
declare_enum <-
  declare_enum_begin _ declare_enum_field* _ 'end' {
    ///TODO: Generate structure and constant from queue
    printf(
      "  // end\n"
      "  }\n"
      "\n"
    );
  }

declare_enum_begin <-
  'enum' _ <IDENT> {
    ///TODO: Queue declarations
    $$ = 0;
    printf( "  // %s\n", $0 );
    printf( "  enum {\n", $1 );
  }

declare_enum_field <-
  &'end'
/ <IDENT> _ '=' _ <CONSTEXPR> _ {
    $$ = atoi($2);
    printf( "    %s = %s // %i\n", $1, $2, $$++ );
  }
/ <IDENT> _ {
    printf( "    %s // %i\n", $3, $$++ );
  }
# End enum declaration grammar

# Begin type declaration grammar
declare_type <-
  'type' _ TYPESPEC _ <IDENT>
# End type declaration grammar

# Begin run block grammar
run_block <-
  run_begin _ declare_local_var* _ STATEMENT* _ run_end

run_begin <-
  'run' {
    printf(
      "int main( int paramArgc, char* paramArgv[] ) {\n"
      "  argc = paramArgc;\n"
      "  argv = paramArgv;\n\n"
    );
  }

run_end <-
  'end' {
    printf(
      "\n"
      "  // end\n}"
    );
  }
# End run block grammar

# Begin statement grammar
STATEMENT <-
  &'end'
/ # Function/Method call
  _ <QUALIFIEDIDENT _ '(' _ (EXPR (_ ',' _ EXPR)*)* _ ')'> _ {
    printf( "  %s\n", $1 );
  }
/ # Variable expression assignment
  _ <QUALIFIEDIDENT _ ASSIGNOP _ EXPR> _ {
    printf( "  %s\n", $2 );
  }
/ # Pointer address assignment expression
  _ <'@'QUALIFIEDIDENT _ ASSIGNOP _ EXPR> _ {
    printf( "  %s\n", $3 );
  }
# End statement grammar

# Begin constant expression gramamr
CONSTEXPR <-
  EXPR
# End constant expression grammar

# Begin expression grammar
EXPR <-
  SUBEXPR

SUBEXPR <-
  LOGICALOR

LOGICALOR <-
  LOGICALOR _ '||' _ LOGICALAND
/ LOGICALAND

LOGICALAND <-
  LOGICALAND _ '&&' _ BITOR
/ BITOR

BITOR <-
  BITOR _ '|' _ BITXOR
/ BITXOR

BITXOR <-
  BITXOR _ '^' _ BITAND
/ BITAND

BITAND <-
  BITAND _ '&' _ EQUALS
/ EQUALS

EQUALS <-
  EQUALS _ ('==' / '!=') _ COMPARE
/ COMPARE

COMPARE <-
  COMPARE _ ('<' / '<=' / '>' / '>=') _ SHIFT
/ SHIFT

SHIFT <-
  SHIFT _ ('<<' / '>>') _ TERM
/ TERM

TERM <-
  TERM _ ('+' / '-') _ FACTOR
/ FACTOR

FACTOR <-
  FACTOR _ ('*' / '/' / '%') _ UNARYOP
/ UNARYOP

UNARYOP <-
  ('+' / '-' / '~' / '!') _ UNARYOP
/ OPERAND

OPERAND <-
  <INTNUM>
/ QUALIFIEDIDENT _ '(' _ SUBEXPR _ ')'
/ (('++' / '--' / '@') _)? QUALIFIEDIDENT (_ ('++'/'--'))?
/ '(' _ SUBEXPR _ ')'
# End expression grammar

# Begin type definitions
TYPESPEC <-
  BASETYPE
/ <IDENT>

BASETYPE <-
  'int' / 'int8' / 'int16' / 'int32' /
  'uint' / 'uint8' / 'uint16' / 'uint32' / 'uint64' /
  'bool' / 'char'
# End type definitions

# Begin tokenizer definitions
EOF <- !.

_ <- SPACE

SPACE <- [ \t\r\n]*

ASSIGNOP <-
  '=' / '+=' / '-=' / '*=' / '/=' / '%='
  / '<<=' / '>>=' / '&=' / '^=' / '|='

INTNUM <- [0-9]+
IDENT <- [_a-zA-Z][_a-zA-Z0-9]*
QUALIFIEDIDENT <- IDENT (_ '.' _ IDENT)*
# End tokenizer definitions

%%

int main( int argc, char* argv[] ) {
  pcc_context_t *ctx = pcc_create(NULL);

  while( pcc_parse(ctx, NULL) ) {
  };

  pcc_destroy( ctx );

  return 0;
}
