
%header {
  enum PointerType {
    ptrData = 1
  };

  typedef struct TypeSpec {
    unsigned pointerType;
    char simpleTypeName[2048];
    unsigned elementCount;
  } TypeSpec;
}

%source {
  char declIdent[4192] = {};

  TypeSpec typeSpec = {};

  // begin strnlen copied from packcc.c source file, as a workaround for TinyCC
  static size_t strnlen(const char *str, size_t maxlen) {
    size_t i;
    for( i = 0; (i < maxlen) && str[i]; i++ ) {
    };
    return i;
  }
  // end

/*
  static const char *dbg_str[] = { "Evaluating rule", "Matched rule", "Abandoning rule" };
  #define PCC_DEBUG(event, rule, level, pos, buffer, length) \
    if( (event == 0) || (event == 2) ) {\
      fprintf(stderr, "%*s%s %s @%d [%.*s]\n", level * 2, "", dbg_str[event], rule, pos, length, buffer);\
    }
*/

  void TranslateTypeSpec( TypeSpec* ts, char* ident ) {
    if( !(ts && ident) ) {
      printf( "Internal Error: NULL TypeSpec and/or ident passed to TranslateTypeSpec.\n" );
      exit(1);
    }

    printf( "%s ", ts->simpleTypeName );
    if( ts->pointerType == ptrData ) {
      printf( "*" );
    }
    if( ts->elementCount ) {
      printf( "%s[%u]", ident, ts->elementCount );
    } else {
      printf( "%s", ident );
    }
  }
}

source_header <-
  _ program_declaration (toplevel)* run_block (toplevel)* _ EOF {
  }

program_declaration <- 'program' _ <IDENT> _ {
  printf( "// %s\n", $0 );
  printf(
  "#include <stdbool.h>\n"
  "#include <stdint.h>\n"
  "#include <stdlib.h>\n"
  "  typedef unsigned uint;\n"
  "  typedef int8_t int8;\n"
  "  typedef int16_t int16;\n"
  "  typedef int32_t int32;\n"
  "  typedef int32_t int32;\n\n"
  "  typedef uint8_t uint8;\n"
  "  typedef uint16_t uint16;\n"
  "  typedef uint32_t uint32;\n"
  "  typedef uint32_t uint32;\n\n"
  "  typedef uint64_t fsize;\n\n"
  "  typedef size_t size;\n\n" );
}

toplevel <-
  enum_declaration _ (enum_field_declaration)* _ 'end' _ {
    printf( "  };\n\n" );
  }
/ 'type' _ <TYPESPEC> _ <IDENT> _ '=' _ <CONSTEXPR> _ {
    printf( "// %s\n", $0 );

    // typedef
    printf( "  typedef " );
    TranslateTypeSpec( &typeSpec, (char*)$2 );
    printf( ";\n\n" );

    // default value
    printf( "  const %s ", typeSpec.simpleTypeName );
    if( typeSpec.pointerType == ptrData ) {
      printf( "*" );
    }
    printf( "default%s = %s;\n\n", $2, $3 );
  }
/ 'type' _ <TYPESPEC> _ <IDENT> _ {
    printf( "\n// %s\n", $0 );

    // typedef
    printf( "  typedef " );
    TranslateTypeSpec( &typeSpec, (char*)$5 );
    printf( ";\n\n" );
  }

enum_declaration <-
  'enum' _ <IDENT> _ {
    printf( "// %s\n", $0 );
    printf( "  enum %s {\n", $1 );
    $$ = 0; // Init value
  }

enum_field_declaration <-
  &'end'
/ <IDENT> _ '=' _ <CONSTEXPR> _ &'end' {
    $$ = atoi($2);
    printf( "    %s = %s // %i\n", $1, $2, $$ );
  }
/ <IDENT> _ '=' _ <CONSTEXPR> _ {
    $$ = atoi($4);
    printf( "    %s = %s, // %i\n", $3, $4, $$ );
    $$++;
  }
/ <IDENT> _ &'end' {
    printf( "    %s  // %i\n", $5, $$ );
  }
/ <IDENT> _ {
    printf( "    %s, // %i\n", $6, $$ );
    $$++;
  }

local_var_block <- 'var' _ (local_var_declaration)* _ 'end' _ {
}

local_var_declaration <-
  &'end'
/ <TYPESPEC> _ <IDENT> _ '=' _ <EXPR> _ {
    printf( "// %s\n", $0 );
    printf( "  " );
    TranslateTypeSpec( &typeSpec, (char*)$2 );
    printf( " = (%s);\n\n", $3 );
  }
/ <TYPESPEC> _ <IDENT> _ {
    printf( "// %s\n", $0 );
    printf( "  " );
    TranslateTypeSpec( &typeSpec, (char*)$5 );
    printf( ";\n\n" );
  }

run_block <-
  run _ (local_var_block)* _ (statement)* _ 'end' _ {
    printf(
      "  return 0;\n"
      "}\n"
    );
  }

run <- 'run' _ {
  printf( "// run\n" );
  printf(
    "int main( int argc, char* argv[] ) {\n\n"
  );
}

statement <-
  &'end'
/ if_statement _ <'then' _ statement> _ {
    printf( "// %s\n", $1 );
    printf( "  }\n\n" );
  }
/ 'goto' _ <IDENT> _ {
    printf( "// %s\n", $2 );
    printf( "  goto %s;\n", $2 );
  }
/ 'exit' _ '(' _ <EXPR> _ ')' _ {
    printf( "  exit( %s );\n", $3 );
  }
/ <IDENT>':' _ {
    printf( "%s:", $4 );
  }

if_statement <-
  'if' _ <CONDITION> {
    printf( "// %s\n", $0 );
    printf( "  if( %s ) {\n", $1 );
  }

_ <- (SPACE / EOL / MLCOMMENT)*

SPACE <- ' ' / '\t'

EOL <- '\r\n' / '\n' / '\r'

EOF <- !.

MLCOMMENT <- '/*' ( (!'*/' .)* '*/')*

IDENT <- [_a-zA-Z][_a-zA-Z0-9]*

INTNUM <- [0-9]+

BASETYPE <-
  ('int' / 'int8' / 'int16' / 'int32')
/ ('uint' / 'uint8' / 'uint16' / 'uint32')
/ 'bool'
/ 'char'

SIMPLETYPE <- BASETYPE / IDENT

TYPESPEC <- <[@]?> _ <SIMPLETYPE> _ ('[' _ <CONSTEXPR> _ ']')? _ {
  memset( &typeSpec, 0, sizeof(typeSpec) );

  if( strcmp($1, "@") == 0 ) {
    typeSpec.pointerType = ptrData;
  }

  strcpy( typeSpec.simpleTypeName, $2 );

  if( strlen($3) > 0 ) {
    typeSpec.elementCount = atoi($3);
  }
}

CONDITION <- IDENT / INTNUM

EXPR <- IDENT / INTNUM

CONSTEXPR <- EXPR

%%

int main( int argc, char* argv[] ) {
  pcc_context_t *ctx = pcc_create(NULL);

  while( pcc_parse(ctx, NULL) ) {
  };

  pcc_destroy( ctx );

  return 0;
}
