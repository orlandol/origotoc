
==

program IDENT

// program IDENT
#include "IDENT.H"

==

const TYPESPEC IDENT = CEXPR

static const TYPESPEC IDENT = CEXPR;

==

enum BASETYPE IDENT
  IDENT, ... = CEXPR
  ...
end


==

struct IDENT
  TYPESPEC IDENT, ...
  union (TYPESPEC, ...) IDENT, ...
  ...
end

typedef struct IDENT
  TYPESPEC IDENT, ...;
  ...
} IDENT;

==

type @TYPENAME[CEXPR] IDENT = CEXPR

#define DEFAULT_IDENT (CEXPR)
typedef TYPENAME[CEXPR]* IDENT;

==

var
  TYPESPEC IDENT, ... = CEXPR
  ...
end

TYPESPEC IDENT = CEXPR;
TYPESPEC ... = CEXPR;
...

==

import TYPESPEC IDENT( TYPESPEC IDENT, ... )
  from FILENAME as IDENT

// To intermediate Header file
extern __declspec(dllimport) TYPESPEC IDENT( TYPESPEC IDENT, ... );

// To list sorted by DLL name
// Then all to PROGNAME.def in EndParse()
...
LIBRARY DLLFILENAME
EXPORTS
IDENT
...

==

funcdecl TYPESPEC IDENT( TYPESPEC IDENT, ... )

TYPESPEC IDENT( TYPESPEC IDENT, ... );

==

func TYPESPEC IDENT( TYPESPEC IDENT, ... )
  var
    TYPESPEC IDENT, ... = CEXPR
    ...
  end

  STATEMENTS
  result ASSIGNOP EXPR
  return EXPR
  ...
end

// To intermediate Header file
TYPESPEC IDENT( TYPESPEC IDENT, ... );

// To intermediate C file
TYPESPEC IDENT( TYPESPEC IDENT, ... ) {
  TYPESPEC IDENT = CEXPR;
  TYPESPEC ... = CEXPR;
  ...
  result = DEFAULT;

  STATEMENTS;
  result ASSIGNOP EXPR;
  return result;
}

==

object IDENT
  inherits OBJNAME, ...
mutable
immutable
  TYPESPEC FIELDIDENT, ...
  ...
end

typedef struct IDENT {
  TYPESPEC INHERITEDFIELDNAME, ...;
  TYPESPEC FIELDIDENT, ...;
} IDENT;

==

abstract IDENT
  implements OBJNAME
  inherits IFNAME, ...

  method TYPESPEC IDENT( TYPESPEC IDENT, ... )
end

typedef struct IFNAMETYPE {
  TYPESPEC (*INHERITEDMETHODNAME)( OBJNAME* self, TYPESPEC IDENT, ... );
  TYPESPEC (*METHODNAME)( OBJNAME* self, TYPESPEC IDENT, ... );
  ...
} IFNAMETYPE;

static const IFNAMETYPE IFNAME = {
  IFNAME_METHODNAME,
  ...
};

==

interface IDENT
  implements OBJNAME
  inherits IFNAME, ...

  method TYPESPEC IDENT( TYPESPEC IDENT, ... )
  ...
end

typedef struct IFNAMETYPE {
  TYPESPEC (INHERITEDMETHODNAME*)( OBJNAME* self, TYPESPEC IDENT, ... );
  TYPESPEC (*METHODNAME)( OBJNAME* self, TYPESPEC IDENT, ... );
  ...
} IFNAMETYPE;

static const IFNAMETYPE IFNAME = {
  IFNAME_METHODNAME,
  ...
};

==

method IFNAME.METHODNAME( TYPESPEC IDENT, ... )
  var
    TYPESPEC IDENT = CEXPR, ... = CEXPR
    ...
  end

  STATEMENTS
  OBJSTATEMENTS
  result ASSIGNOP EXPR
  return EXPR
end

TYPESPEC IFNAME_METHODNAME( OBJNAME* self, TYPESPEC IDENT, ... ) {
  TYPESPEC IDENT = CEXPR;
  TYPESPEC ... = CEXPR;
  ...
  result = DEFAULT;

  STATEMENTS;
  OBJSTATEMENTS;
  result ASSIGNOP EXPR;
  return EXPR;
}

==

operator TYPESPEC OPER( TYPESPEC VALUE, ... )
  var
    TYPESPEC IDENT, ... = CEXPR
    ...
  end

  STATEMENTS
  result ASSIGNOP EXPR
  return EXPR
end

TYPESPEC OPERNAME( TYPESPEC VALUE, TYPESPEC ..., ... ) {
  result = DEFAULT;

  STATEMENTS;
  result ASSIGNOP EXPR;
  return result;
}

==

run
  var
    TYPESPEC IDENT, ... = CEXPR
  end

  STATEMENTS
end

int paramCount = 0;
char** param = NULL;
int main( int argc, char* argv[] ) {
  paramCount = argc;
  param = argv;

  return 0;
}

==

FUNCCALL( EXPR, ... )

FUNCCALL( EXPR, ... );

==

METHODCALL( EXPR, ... )

METHODCALL( EXPR, ..., OBJVAR );

==

bind( OBJVAR, IFNAME, IFNAME.METHODNAME, ... )

memcpy( IFVAR, IFNAME, sizeof(IFNAME) );
IFVAR.METHODNAME = IFNAME.METHODNAME;
...

==

VARREF ASSIGNOP EXPR

VARREF ASSIGNOP EXPR;

==

if CONDITION then STATEMENT

if( CONDITION ) {
  STATEMENT;
}

==

if CONDITION
  STATEMENTS
elseif CONDITION
  STATEMENTS
else
  STATEMENTS
endif

if( CONDITION ) {
  STATEMENTS;
} else if( CONDITION ) {
  STATEMENTS;
} else {
  STATEMENTS;
}

==

for VARREF in [CEXPR, ...]
  STATEMENTS
  next
  break
endfor

for( indexVARNAME = 0; indexVARNAME < MAX_VARNAME; indexVARNAME++ ) {
  valueVARNAME = constVARNAME[indexVARNAME];

  STATEMENTS;
  continue;
  break;
}

==

for VARREF = EXPR to EXPR
  STATEMENTS
  next
  break
endfor

for( VARREF = EXPR; VARREF < EXPR; VARREF++ ) {
  STATEMENTS;
  continue;
  break;
}

==

echo( EXPR, ... )

printf( STRFMT, EXPR, ... );

==

echoln( EXPR, ... )

printf( STRFMT"\n", EXPR, ... );

==

repeat
  STATEMENTS
  next
  break
when CONDITION

do {
  STATEMENTS;
  continue;
  break;
} while( !(CONDITION) );

==

while CONDITION
  STATEMENTS
  next
  break
endwhile

while( CONDITION ) {
  STATEMENTS;
  continue;
  break;
}

==

:Label

Label:

==

goto LABELNAME

goto LABELNAME;

==
