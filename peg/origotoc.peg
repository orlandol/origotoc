
%header {
  #include "keyarray.h"

  // begin version format Maj.Min.Patch.ReleaseType declarations
  #define EXPERIMENTAL_RELEASE 7
  #define ALPHA_RELEASE 8
  #define GAMMA_RELEASE 9
  #define BETA_RELEASE 10
  #define RELEASE_CANDIDATE 11
  #define STABLE_RELEASE 12
  #define HOTFIX_RELEASE 13
  #define LTS_RELEASE 14
  #define FINAL_RELEASE 15

  #define MAKEVEREXT(major, minor, patch, release)\
    ((((major) & 0xFF) << 24) | (((minor) & 0xFF) << 16) |\
     (((patch) & 0x0FFF) << 4) | ((release) & 0x000F))

  #define MAJORVEREXT(version) (((version) >> 24) & 0xFF)
  #define MINORVEREXT(version) (((version) >> 16) & 0xFF)
  #define PATCHVEREXT(version) (((version) >> 4) & 0x0FFF)
  #define RELEASETYPEEXT(version) ((version) & 0x000F)
  // end version format declarations

  // begin general declarations
  #define IDENT_MAXLEN 32
  #define IDENT_MAXINDEX (IDENT_MAXLEN - 1)
  #define IDENTPAIR_MAXLEN 64
  #define IDENTPAIR_MAXINDEX (IDENTPAIR_MAXLEN - 1)

  #define TOKENSTR_MAXLEN 2048
  #define TOKENSTR_MAXINDEX (TOKENSTR_MAXLEN - 1)
  // end general declarations

  // begin enum field declarations
  typedef struct EnumField {
    char name[IDENT_MAXLEN];
    unsigned value;
  } EnumField;

  DECLARE_STRING_KEYARRAY_TYPES( EnumFieldTable, EnumField )

  void FreeEnumField( EnumField* data );
  int CopyEnumField( EnumField* dest, EnumField* source );
  // end enum field declarations

  // begin symbol table declarations
  typedef struct TypeSpec {
    int pointerType;
    unsigned simpleType;
    char simpleTypeName[IDENTPAIR_MAXLEN];
    unsigned dimCount;
  } TypeSpec;

  typedef struct Symbol {
    int tokenCode;
  } Symbol;

  DECLARE_STRING_KEYARRAY_TYPES( SymTable, Symbol )
  // end symbol table declarations
}

%source {
  // begin strnlen copied from packcc.c source file, as a workaround for TinyCC
  static size_t strnlen(const char *str, size_t maxlen) {
    size_t i;
    for( i = 0; (i < maxlen) && str[i]; i++ ) {
    };
    return i;
  }
  // end

/*
  static const char *dbg_str[] = { "Evaluating rule", "Matched rule", "Abandoning rule" };
  #define PCC_DEBUG(event, rule, level, pos, buffer, length) \
      fprintf(stderr, "%*s%s %s @%d [%.*s]\n", level * 2, "", dbg_str[event], rule, pos, length, buffer);
*/

  #include "keyarray.h"

  // begin helper functions
  void FreePtr( void** ptrVar ) {
    if( ptrVar ) {
      if( *ptrVar ) {
        free( *ptrVar );
        *ptrVar = NULL;
      }
    }
  }
  // end helper functions

  // begin path functions
  int SplitPath( const char* fromFullPath, char** toDir,
    char** toBaseName, char** toExt ) {

    const char* pathCh;
    const char* pathDir;
    const char* pathBaseName;
    const char* pathExt;
    size_t curLen = 0;
    size_t dirLen = 0;
    size_t basenameLen = 0;
    size_t extLen = 0;
    char* newDir = NULL;
    char* newBaseName = NULL;
    char* newExt = NULL;

    // Validate parameters
    if( (fromFullPath == NULL) || (*fromFullPath == '\0') ) { return 1; }
    if( (toDir == NULL) || *toDir ) { return 2; }
    if( (toBaseName == NULL) || *toBaseName ) { return 3; }
    if( (toExt == NULL) || *toExt ) { return 4; }

    pathDir = fromFullPath;
    pathBaseName = fromFullPath;
    pathExt = fromFullPath;

    // Find last \ or / in file path
    pathCh = pathDir;
    curLen = 0;
    while( *pathCh )  {
      if( *pathCh == '\\' || *pathCh == '/' ) {
        pathBaseName = pathCh + 1;
        dirLen = curLen + 1;
      }
      pathCh++;
      curLen++;
    }

    // Find the first . after the last \ or /
    pathCh = pathBaseName;

    if( (*pathCh == '.') ) {
      // Special case .file as base name, when [dir\ or dir/].file[.ext]
      pathCh++;
      pathExt = pathCh;
      basenameLen++;
    }

    while( *pathCh )  {
      if( *pathCh == '.' ) {
        pathExt = pathCh;
        break;
      }
      pathCh++;
      basenameLen++;
    }

    // Get the length of the file extension
    pathCh = pathExt;
    extLen = 0;
    while( *pathCh )  {
      if( *pathCh == '.' ) {
        break;
      }
      pathCh++;
      pathExt++;
    }
    while( *pathCh ) {
      pathCh++;
      extLen++;
    }

    if( (dirLen | basenameLen | extLen) == 0 ) { return 5; }

    if( dirLen ) {
      newDir = malloc((dirLen + 1) * sizeof(char));
      if( newDir == NULL ) { goto ExitError; }
      memcpy( newDir, pathDir, dirLen * sizeof(char) );
      newDir[dirLen] = '\0';
      *toDir = newDir;
    }

    if( basenameLen ) {
      newBaseName = malloc((basenameLen + 1) * sizeof(char));
      if( newBaseName == NULL ) { goto ExitError; }
      memcpy( newBaseName, pathBaseName, basenameLen * sizeof(char) );
      newBaseName[basenameLen] = '\0';
      *toBaseName = newBaseName;
    }

    if( extLen ) {
      newExt = malloc((extLen + 1) * sizeof(char));
      if( newExt == NULL ) { goto ExitError; }
      memcpy( newExt, pathExt, extLen * sizeof(char) );
      newExt[extLen] = '\0';
      *toExt = newExt;
    }

    return 0;

  ExitError:
    FreePtr( &newDir );
    FreePtr( &newBaseName );
    FreePtr( &newExt );
    return 6;
  }

  int JoinPath( const char* fromDir, const char* fromBaseName,
    const char* fromExt, char** toFullPath ) {

    char* newPath = NULL;
    size_t totalLen;
    const char* tmpCh;
    char pathSeparator = '\0';
    char extDot = '\0';

    // Validate parameters
    if( (toFullPath == NULL) || *toFullPath ) { return 4; }
    if( (fromDir == NULL) && (fromBaseName == NULL)
      && (fromExt == NULL) ) { return 5; }

    // Calculate the total string length
    totalLen = 0;
    if( fromDir ) {
      totalLen = strlen(fromDir);
      if( totalLen ) {
        // Check for trailing path separator
        if( (fromDir[totalLen - 1] != '\\') && (fromDir[totalLen - 1] != '/') ) {
          totalLen++;
          // If path separator isn't at end, detect which slash to use
          tmpCh = fromDir;
          pathSeparator = '\\'; // default to '\'
          while( *tmpCh ) {
            if( (*tmpCh == '\\') || (*tmpCh == '/') ) {
              pathSeparator = *tmpCh;
              break;
            }
            tmpCh++;
          }
        }
      }
    }

    if( fromBaseName ) {
      totalLen += strlen(fromBaseName);
      // Skip slash at start of BaseName
      if( (*fromBaseName == '\\') || (*fromBaseName == '/') ) {
        fromBaseName++;
        totalLen--;
      }
      // If a slash remains, the base name is [probably?] invalid
      if( (*fromBaseName == '\\') || (*fromBaseName == '/') ) { return 6; }
    }

    if( fromExt ) {
      totalLen += strlen(fromExt);
      // Add a dot if missing from file extension
      if( *fromExt != '.' ) {
        extDot = '.';
        totalLen++;
      }
    }

    // Allocate string buffer
    newPath = malloc((totalLen + 1) * sizeof(char));
    if( newPath == NULL ) { return 7; }
    *newPath = '\0';

    // Copy in each parameter
    if( fromDir ) {
      strcat( newPath, fromDir );
      if( pathSeparator ) {
        strncat( newPath, &pathSeparator, 1 );
      }
    }

    if( fromBaseName ) {
      strcat( newPath, fromBaseName );
    }

    if( fromExt ) {
      if( extDot ) {
        strncat( newPath, &extDot, 1 );
      }
      strcat( newPath, fromExt );
    }

    *toFullPath = newPath;
    return 0;
  }
  // end path functions

  // begin enum field table
  EnumFieldTable* enumFieldTable = NULL;

  void FreeEnumField( EnumField* data ) {
  }

  int CopyEnumField( EnumField* dest, EnumField* source ) {
    return 0;
  }

  DECLARE_STRING_KEYARRAY_CREATE( CreateEnumFieldTable, EnumFieldTable )
  DECLARE_STRING_KEYARRAY_FREE( FreeEnumFieldTable, EnumFieldTable, FreeEnumField )

  DECLARE_STRING_KEYARRAY_INSERT( InsertEnumField, EnumFieldTable, EnumField )
  DECLARE_STRING_KEYARRAY_REMOVE( RemoveEnumField, EnumFieldTable, FreeEnumField )

  DECLARE_STRING_KEYARRAY_RETRIEVE( LookupEnumField, EnumFieldTable, EnumField )
  DECLARE_STRING_KEYARRAY_MODIFY( ModifyEnumField, EnumFieldTable, EnumField )

  DECLARE_STRING_KEYARRAY_FINDINDEX( EnumFieldIndex, EnumFieldTable )

  DECLARE_STRING_KEYARRAY_RELEASEUNUSED( ReleaseUnusedEnumFields, EnumFieldTable )

  DECLARE_STRING_KEYARRAY_COPY( CopyEnumFieldTable, EnumFieldTable, EnumField,
    CopyEnumField, FreeEnumField )
  // end

  // begin symbol table declarations
  void FreeSymbol( Symbol* data ) {
  }

  int CopySymbol( Symbol* dest, Symbol* source ) {
    return 0;
  }

  DECLARE_STRING_KEYARRAY_CREATE( CreateSymTable, SymTable )
  DECLARE_STRING_KEYARRAY_FREE( FreeSymTable, SymTable, FreeSymbol )

  DECLARE_STRING_KEYARRAY_INSERT( InsertSymbol, SymTable, Symbol )
  DECLARE_STRING_KEYARRAY_REMOVE( RemoveSymbol, SymTable, FreeSymbol )

  DECLARE_STRING_KEYARRAY_RETRIEVE( LookupSymbol, SymTable, Symbol )
  DECLARE_STRING_KEYARRAY_MODIFY( ModifySymbol, SymTable, Symbol )

  DECLARE_STRING_KEYARRAY_FINDINDEX( SymbolIndex, SymTable )

  DECLARE_STRING_KEYARRAY_RELEASEUNUSED( ReleaseUnusedSymbols, SymTable )

  DECLARE_STRING_KEYARRAY_COPY( CopySymTable, SymTable, Symbol,
    CopySymbol, FreeSymbol )
  // end symbol table declarations

  // begin global variables
  char qualifier[IDENT_MAXLEN];
  EnumFieldTable* enumTable;
  unsigned enumFieldValue;

  SymTable* symTable = NULL;
  SymTable* localTable = NULL;
  // end global variables
}

program <-
  _ program_header _ (_ declaration)* run_block? _ (_ declaration)* _ EOF {
  }

## Begin program IDENT
program_header <-
  'program' _ <IDENT> {
    printf( "PROGRAM[%s]\n", $1 );
  }
# End program IDENT

## Begin top level declaration
declaration <-
  _ enum_declaration _
/ _ union_declaration _
/ _ struct_declaration _
/ _ type_declaration _
/ _ global_var_declaration_block _
/ _ func_prototype_declaration _
/ _ import_func_declaration _
#/ _ object_declaration _
#/ _ object_new_declaration _
#/ _ object_free_declaration _
#/ _ interface_declaration _
#/ _ method_declaration _
# End top level declaration

## Begin enum ... end
enum_declaration <-
  enum_header (_ enum_field_declaration)* _ 'end' {
  }

enum_header <-
  'enum' _ <IDENT> {
    enumFieldValue = 0;
    strncpy( qualifier, $1, IDENT_MAXINDEX );
    printf( "ENUM[%s]\n", qualifier );
  }

enum_field_declaration <-
  &'end'
/ <IDENT> _ '=' _ <CONSTEXPR> _ ',' _ {
    printf( "ENUMFIELD[%s.%s = %s], ", qualifier, $1, $2 );
  }
/ <IDENT> _ '=' _ <CONSTEXPR> {
    printf( "ENUMFIELD[%s.%s = %s]\n", qualifier, $3, $4 );
  }
/ <IDENT> _ ',' _ {
    printf( "ENUMFIELD[%s.%s], ", qualifier, $5 );
  }
/ <IDENT> _ {
    printf( "ENUMFIELD[%s.%s]\n", qualifier, $6 );
  }
# End enum ... end

## Begin union ... end
union_declaration <-
  union_header (_ union_field_declaration)* _ 'end' {
  }

union_header <-
  'union' _ <IDENT> _ {
    strncpy( qualifier, $1, IDENT_MAXINDEX );
    printf( "UNION[%s]\n", $1 );
  }

# TYPESPEC IDENT
union_field_declaration <-
  &'end'
/ <TYPESPEC> _ <IDENT> _ {
    printf( "UNIONFIELD[%s %s.%s]\n", $1, qualifier, $2 );
  }
# End union ... end

## Begin struct ... end
struct_declaration <-
  struct_header (_ struct_field_declaration)* _ 'end' {
  }

struct_header <-
  'struct' _ <IDENT> _ {
    strncpy( qualifier, $1, IDENT_MAXINDEX );
    printf( "STRUCT[%s]\n", $1 );
  }

# TYPESPEC IDENT
struct_field_declaration <-
  &'end'
/ <TYPESPEC> _ <IDENT> _ {
    printf( "STRUCTFIELD[%s %s.%s]\n", $1, qualifier, $2 );
  }
# End struct ... end

## Begin type declaration
type_declaration <-
  'type' _ <TYPESPEC> _ <IDENT> _ '=' _ <CONSTEXPR> {
    printf( "TYPE[%s %s = %s]\n", $1, $2, $3 );
  }
/ 'type' _ <TYPESPEC> _ <IDENT> _ {
    printf( "TYPE[%s %s]\n", $4, $5 );
  }

## End type declaration

## Begin global var declaration
global_var_declaration_block <-
  global_var_begin (_ global_var_declaration)* _ 'end' {
  }

global_var_begin <-
  'var' _ {
  }

global_var_declaration <-
  &'end'
/ <TYPESPEC> _ <IDENT> _ '=' _ <EXPR> _ {
    printf( "GLOBALVAR[%s %s = %s]\n", $1, $2, $3 );
  }
/ <TYPESPEC> _ <IDENT> _ {
    printf( "GLOBALVAR[%s %s]\n", $4, $5 );
  }
# End global var declaration

## Begin parameter declarations
parameter_declarations <-
  _ parameter_declaration (_ ',' _ parameter_declaration)* _ {
  }

parameter_declaration <- <TYPESPEC> _ <IDENT> _
# End parameter declarations

## Begin funcdecl
func_prototype_declaration <-
  func_prototype_begin _ <TYPESPEC> _ <IDENT> _ '(' _ ')' _ {
    printf( "FUNCDECL[%s %s()]\n", $1, $2 );
  }
/ func_prototype_begin _ <TYPESPEC> _ <IDENT> _ '(' _ <parameter_declarations> _ ')' _ {
    printf( "FUNCDECL[%s %s ( %s )]\n", $3, $4, $5 );
  }

func_prototype_begin <-
  'funcdecl' {
  }
# End funcdecl

## Begin import function
import_func_declaration <-
  import_func_begin _ import_func_spec? _ import_func_name _ import_func_parameters? _
    import_func_from _ import_func_as? _ {
    printf( "\n" );
  }

import_func_begin <-
  'import' _ 'func' {
    printf( "IMPORTFUNC" );
  }

import_func_spec <-
  <CALLSPEC> _ <TYPESPEC> {
    printf( "[%s %s]", $1, $2 );
  }
/ <CALLSPEC> {
    printf( "[%s]", $3 );
  }
/ <TYPESPEC> {
    printf( "[%s]", $4 );
  }

import_func_name <-
  <IDENT> {
    printf( "[%s]", $1 );
  }

import_func_parameters <-
  '(' _ <parameter_declarations> _ ')' {
    printf( "(%s)", $1 );
  }

import_func_from <-
  'from' _ <STRING> {
    printf( "[from %s]", $1 );
  }

import_func_as <-
  'as' _ <IDENT> {
    printf( "[as %s]", $1 );
  }
# Emd import function

## Begin run ... end
run_block <-
  run_begin (_ statement)* _ 'end' {
    printf( "RUN\n" );
  }

run_begin <-
  'run' {
  }
# End run ... end

## Begin statement
statement <-
  &'end'
/ <IDENT> _ ':' {
    printf( "LABEL[%s]\n", $1 );
  }
/ 'gpto' _ <IDENT> {
    printf( "GOTO[%s]\n", $2 );
  }
# End statement

## Begin call spec
CALLSPEC <- 'cdecl' / 'stdcall'
# End call spec

## Begin type spec
TYPESPEC <-
  '@' _ (SIMPLETYPE / 'any') _ '[' _ ']'
/ '@' _ (SIMPLETYPE / 'any') _ '[' _ <CONSTEXPR> _ ']'
/ '@' _ (SIMPLETYPE / 'any')
/ SIMPLETYPE _ '[' _ <CONSTEXPR> _ ']'
/ SIMPLETYPE

SIMPLETYPE <-
  BASETYPE

BASETYPE <-
  'int8' / 'int16' / 'int32' / 'int64' / 'int'
/ 'uint8' / 'uint16' / 'uint32' / 'uint64' / 'uint'
/ 'char' / 'bool' / 'size' / 'fsize'
/ (!'any' TYPENAME)
# End type spec

## Begin runtime expression
# Expression must evaluate to an immediate value
EXPR <-
  INTNUM
/ QUALIFIEDIDENT

# End runtime expression

## Begin constant expression
# Expression must evaluate to an immediate value
CONSTEXPR <-
  INTNUM
/ CONSTIDENT

CONSTIDENT <-
  <IDENT> {
  }
# End constant expression

## Begin expression tokens
INTNUM <-
  '0b'[0-1]+
/ '0o'[0-7]+
/ '0x'[0-9a-fA-F]+
/ [0-9]+
# End expression tokens

## Begin tokens
STRING <-
  "'" (!"'" .)* "'"
/ '"' (!'"' .)* '"'

# TYPENAME must be in the symbol table
TYPENAME <- [_a-zA-Z][_a-zA-Z0-9]* {
}

QUALIFIEDIDENT <-
  <IDENT>

IDENT <- [_a-zA-Z][_a-zA-Z0-9]*

_ <- (NONTERMINAL / MLCOMMENT / SLCOMMENT)*

NONTERMINAL <- [ \t\r\n]

MLCOMMENT <- '/*' (!'*/' .)* '*/'
SLCOMMENT <- '//' (!EOL .)* EOL

EOL <- '\r\n' / '\r' / '\n'

EOF <- !.
# End tokens

%%

void Cleanup() {
  FreeSymTable( &symTable );
  FreeSymTable( &localTable );

  FreeEnumFieldTable( &enumFieldTable );
}

int main( int argc, char* argv[] ) {
  atexit( Cleanup );

  pcc_context_t *ctx = pcc_create(NULL);

  while( pcc_parse(ctx, NULL) ) {
  };

  pcc_destroy( ctx );

  return 0;
}
