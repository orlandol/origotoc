
%header {
  enum PointerType {
    ptrData = 1
  };

  typedef struct TypeSpec {
    unsigned pointerType;
    char simpleTypeName[2048];
    unsigned elementCount;
  } TypeSpec;
}

%source {
  char declIdent[4192] = {};

  TypeSpec typeSpec = {};

  // begin strnlen copied from packcc.c source file, as a workaround for TinyCC
  static size_t strnlen(const char *str, size_t maxlen) {
    size_t i;
    for( i = 0; (i < maxlen) && str[i]; i++ ) {
    };
    return i;
  }
  // end

/*
  static const char *dbg_str[] = { "Evaluating rule", "Matched rule", "Abandoning rule" };
  #define PCC_DEBUG(event, rule, level, pos, buffer, length) \
    if( (event == 0) || (event == 2) ) {\
      fprintf(stderr, "%*s%s %s @%d [%.*s]\n", level * 2, "", dbg_str[event], rule, pos, length, buffer);\
    }
*/

  void TranslateTypeSpec( TypeSpec* ts, char* ident ) {
    if( !(ts && ident) ) {
      printf( "Internal Error: NULL TypeSpec and/or ident passed to TranslateTypeSpec.\n" );
      exit(1);
    }

    printf( "%s ", ts->simpleTypeName );
    if( ts->pointerType == ptrData ) {
      printf( "*" );
    }
    if( ts->elementCount ) {
      printf( "%s[%u]", ident, ts->elementCount );
    } else {
      printf( "%s", ident );
    }
  }
}

source_header <-
  _ program_declaration (toplevel)* run_block (toplevel)* _ EOF {
  }

program_declaration <- 'program' _ <IDENT> _ {
  printf( "// %s\n", $0 );
  printf(
    "#include <stdbool.h>\n"
    "#include <stdint.h>\n"
    "#include <stdlib.h>\n\n"
    "  typedef unsigned uint;\n"
    "  typedef int8_t int8;\n"
    "  typedef int16_t int16;\n"
    "  typedef int32_t int32;\n"
    "  typedef int32_t int32;\n\n"
    "  typedef uint8_t uint8;\n"
    "  typedef uint16_t uint16;\n"
    "  typedef uint32_t uint32;\n"
    "  typedef uint32_t uint32;\n\n"
    "  typedef uint64_t fsize;\n\n"
    "  typedef unsigned size;\n\n"
    "  int argc;\n"
    "  char** argv = NULL;\n\n"
  );
}

toplevel <-
  enum_declaration _ (enum_field_declaration)* _ 'end' _ {
    printf( "  };\n\n" );

    memset( &typeSpec, 0, sizeof(typeSpec) );
    memset( declIdent, 0, sizeof(declIdent) );
  }
/ union_declaration _ (union_field_declaration)* _ 'end' _ {
    printf( "  } %s;\n", declIdent );

    memset( &typeSpec, 0, sizeof(typeSpec) );
    memset( declIdent, 0, sizeof(declIdent) );
  }
/ struct_declaration _ (struct_field_declaration)* _ 'end' _ {
    printf( "  } %s;\n", declIdent );

    memset( &typeSpec, 0, sizeof(typeSpec) );
    memset( declIdent, 0, sizeof(declIdent) );
  }
/ type_tspec_ident _ type_default_value _ {
    printf( ";\n\n" );

    printf( "// ^ %s\n", $0 );

    memset( &typeSpec, 0, sizeof(typeSpec) );
    memset( declIdent, 0, sizeof(declIdent) );
  }
/ 'type' _  _ <IDENT> _ {
    printf( "\n// %s\n", $0 );

    // typedef
    printf( "  typedef " );
    TranslateTypeSpec( &typeSpec, (char*)$1 );
    printf( ";\n\n" );

    memset( &typeSpec, 0, sizeof(typeSpec) );
    memset( declIdent, 0, sizeof(declIdent) );
  }
/ 'const' _ (const_value_declaration)* _ 'end' _ {
    memset( &typeSpec, 0, sizeof(typeSpec) );
    memset( declIdent, 0, sizeof(declIdent) );
  }
/ 'var' _ (global_var_declaration)* _ 'end' _ {
    memset( &typeSpec, 0, sizeof(typeSpec) );
    memset( declIdent, 0, sizeof(declIdent) );
  }
/ funcdecl _ callspec? _ func_name _ '(' _ (paramdecl)* _ ')' _ {
    printf( ");\n" );
    printf( "// ^ %s\n", $0 );

    memset( &typeSpec, 0, sizeof(typeSpec) );
    memset( declIdent, 0, sizeof(declIdent) );
  }
/ import_func _ callspec? _ func_name _ '(' _ (paramdecl)* _ ')' _ {
    printf( ");\n" );
    printf( "// ^ %s\n", $0 );

    memset( &typeSpec, 0, sizeof(typeSpec) );
    memset( declIdent, 0, sizeof(declIdent) );
  }
/ func _ callspec? _ func_name _ '(' _ (paramdecl)* _ func_close_param _ (local_var_block)* _ (func_statement)* _ end_func _ {
    memset( &typeSpec, 0, sizeof(typeSpec) );
    memset( declIdent, 0, sizeof(declIdent) );
  }

enum_declaration <-
  'enum' _ <IDENT> _ {
    printf( "// %s\n", $0 );
    printf( "  enum %s {\n", $1 );
    $$ = 0; // Init value
  }

enum_field_declaration <-
  &'end'
/ <IDENT> _ '=' _ <CONSTEXPR> _ &'end' {
# Replace atoi with string expression
    $$ = atoi($2);
    printf( "    %s = %s // %i\n", $1, $2, $$ );
  }
/ <IDENT> _ '=' _ <CONSTEXPR> _ {
# Replace atoi with string expression
    $$ = atoi($4);
    printf( "    %s = %s, // %i\n", $3, $4, $$ );
    $$++;
  }
/ <IDENT> _ &'end' {
    printf( "    %s  // %i\n", $5, $$ );
  }
/ <IDENT> _ {
    printf( "    %s, // %i\n", $6, $$ );
    $$++;
  }

type_tspec_ident <-
  type _ TYPESPEC _ <IDENT> _ {
    strcpy( declIdent, $1 );
  }

type_default_value <-
  '=' _ CONSTEXPR _ {
    // typedef
    printf( "  typedef " );
    TranslateTypeSpec( &typeSpec, declIdent );
    printf( ";\n\n" );

    // default value
    printf( "  const %s ", declIdent );
    if( typeSpec.pointerType == ptrData ) {
      printf( "*" );
    }
    printf( "default%s = ", declIdent );
  }

type <-
  'type' {
    printf( "  typedef " );
  }

union_declaration <-
  'union' _ <IDENT> _ {
    printf( "// %s\n", $0 );
    printf( "typedef union %s {\n", $1 );

    strcpy( declIdent, $1 );
  }

union_field_declaration <-
  &'end'
/ TYPESPEC _ <IDENT> _ ',' _ {
    printf( "// %s\n", $0 );
    printf( "  " );
    TranslateTypeSpec( &typeSpec, (char*)$1 );
    printf( ", " );
  }
/ TYPESPEC _ <IDENT> _ {
    printf( "// %s\n", $0 );
    printf( "  " );
    TranslateTypeSpec( &typeSpec, (char*)$2 );
    printf( ";\n" );
  }

struct_declaration <-
  'struct' _ <IDENT> _ {
    printf( "// %s\n", $0 );
    printf( "typedef struct %s {\n", $1 );

    strcpy( declIdent, $1 );
  }

struct_field_declaration <-
  &'end'
/ TYPESPEC _ <IDENT> _ ',' _ {
    printf( "// %s\n", $0 );
    printf( "  " );
    TranslateTypeSpec( &typeSpec, (char*)$1 );
    printf( ", " );
  }
/ TYPESPEC _ <IDENT> _ {
    printf( "// %s\n", $0 );
    printf( "  " );
    TranslateTypeSpec( &typeSpec, (char*)$2 );
    printf( ";\n\n" );
  }

const_value_declaration <-
  &'end'
/ TYPESPEC _ <IDENT> _ '=' _ <CONSTEXPR> _ {
    printf( "// %s\n", $0 );
    printf( "  const " );
    TranslateTypeSpec( &typeSpec, (char*)$1 );
    printf( " = (%s);\n\n", $2 );
  }

global_var_declaration <-
  &'end'
/ <TYPESPEC> _ <IDENT> _ '=' _ <CONSTEXPR> _ {
    printf( "// %s\n", $0 );
    printf( "  " );
    TranslateTypeSpec( &typeSpec, (char*)$2 );
    printf( " = (%s);\n\n", $3 );
  }
/ <TYPESPEC> _ <IDENT> _ {
    printf( "// %s\n", $0 );
    printf( "  " );
    TranslateTypeSpec( &typeSpec, (char*)$5 );
    printf( ";\n\n" );
  }

callspec <-
  <CALLSPEC> _ {
    printf( "__%s ", $1 );
  }

paramdecl <-
  TYPESPEC _ <IDENT> _ ',' _ {
    TranslateTypeSpec( &typeSpec, (char*)$1 );
    printf( ", " );
  }
/ TYPESPEC _ <IDENT> _ {
    TranslateTypeSpec( &typeSpec, (char*)$2 );
    printf( " " );
  }

funcdecl <-
  'funcdecl' _ {
     printf( "  " );
  }

func <-
  'func' _ {
     printf( "  " );
  }

end_func <-
  'end' _ {
    printf( "  }\n\n" );
  }

func_name <-
  TYPESPEC _ <IDENT> _ {
    TranslateTypeSpec( &typeSpec, (char*)$1 );
    printf( " ( " );
  }
/ <IDENT> _ {
    printf( "void %s ( ", $2 );
  }

import_func <-
  'import' _ 'func' _ {
     printf( "  extern " );
  }

local_var_block <-
  'var' _ (local_var_declaration)* _ 'end' _ {
    memset( &typeSpec, 0, sizeof(typeSpec) );
    memset( declIdent, 0, sizeof(declIdent) );
  }

local_var_declaration <-
  &'end'
/ typespec_ident_expr '=' _ EXPR _ {
    printf( ";\n\n" );
    printf( "// ^ %s\n", $0 );
  }
/ TYPESPEC _ <IDENT> _ {
    printf( "// %s\n", $0 );
    printf( "  " );
    TranslateTypeSpec( &typeSpec, (char*)$1 );
    printf( ";\n\n" );
  }

typespec_ident_expr <-
  TYPESPEC _ <IDENT> _ {
    printf( "  " );
    TranslateTypeSpec( &typeSpec, (char*)$1 );
    printf( " = " );
  }

run_block <-
  run _ (local_var_block)* _ (statement)* _ 'end' _ {
    printf(
      "  return 0;\n"
      "}\n"
    );
  }

run <- 'run' _ {
  printf( "// run\n" );
  printf(
    "int main( int paramArgc, char* paramArgv[] ) {\n"
    "  argc = paramArgc;\n"
    "  argv = paramArgv;\n\n"
  );
}

func_close_param <-
  ')' _ {
    printf( ") {\n" );
  }

func_statement <-
  &'end'
/ return _ '(' _ EXPR _ ')' _ {
    printf( ";\n" );
    printf( "// ^ %s\n", $0 );
  }
/ return _ {
    printf( ";\n" );
    printf( "// ^ %s\n", $0 );
  }
/ statement

return <-
  'return' _ {
    printf( "  return "  );
  }

statement <-
  &'end'
/ if_statement _ 'then' _ statement _ {
    printf( "  }\n\n" );
  }
/ if_statement _ (statement)* _ (elseif_statement _ (statement)*)? _ (else_statement _ (statement)*)? _ 'endif' _ {
    printf( "// endif\n" );
    printf( "  }\n\n" );
  }
/ 'goto' _ <IDENT> _ {
    printf( "// %s\n", $0 );
    printf( "  goto %s;\n", $1 );
  }
/ exit _ '(' _ EXPR _ ')' _ {
    printf( ");\n" );
    printf( "// ^ %s\n", $0 );
  }
/ <IDENT>':' _ {
    printf( "%s:\n", $2 );
  }

exit <-
  'exit' _ {
    printf( "  exit ( " );
  }

if_statement <-
  if _ CONDITION {
    printf( ") {\n" );
    printf( "// ^ %s\n", $0 );
  }

if <-
  'if' _ {
    printf( "  if( " );
  }

elseif_statement <-
  elseif _ CONDITION {
    printf( ") {\n" );
    printf( "// ^ %s\n", $0 );
  }

elseif <-
  'elseif' _ {
    printf( "  } else if( " );
  }

else_statement <-
  'else' {
    printf( "  } else {\n" );
    printf( "// ^%s\n", $0 );
  }

_ <- (SPACE / EOL / MLCOMMENT)*

SPACE <- ' ' / '\t'

EOL <- '\r\n' / '\n' / '\r'

EOF <- !.

MLCOMMENT <- '/*' ( (!'*/' .)* '*/')*

IDENT <- [_a-zA-Z][_a-zA-Z0-9]*

#STRING <-
#  <"'" (!"'" .)* "'"> {
#    printf( "STRING ': %s\n", $1 );
#  }
#/ <'"' (!'"' .)* '"'> {
#    printf( "STRING \": %s\n", $2 );
#  }

INTNUM <- [0-9]+

BASETYPE <-
  ('int' / 'int8' / 'int16' / 'int32')
/ ('uint' / 'uint8' / 'uint16' / 'uint32')
/ 'bool'
/ 'char'

SIMPLETYPE <- BASETYPE / IDENT

CALLSPEC <- 'stdcall' / 'cdecl'

TYPESPEC <- <[@]?> _ <SIMPLETYPE> _ ('[' _ <CONSTEXPR> _ ']')? _ {
  memset( &typeSpec, 0, sizeof(typeSpec) );

  if( strcmp($1, "@") == 0 ) {
    typeSpec.pointerType = ptrData;
  }

  strcpy( typeSpec.simpleTypeName, $2 );

  if( strlen($3) > 0 ) {
    typeSpec.elementCount = atoi($3);
  }
}

CONDITION <-
  <IDENT> {
    printf( "%s ", $1 );
  }
/ <INTNUM> {
    printf( "%s ", $2 );
  }

EXPR <-
  <IDENT> {
    printf( "%s ", $1 );
  }
/ <INTNUM> {
    printf( "%s ", $2 );
  }

CONSTEXPR <-
  <IDENT> {
    printf( "%s ", $1 );
  }
/ <INTNUM> {
    printf( "%s ", $2 );
  }

%%

int main( int argc, char* argv[] ) {
  pcc_context_t *ctx = pcc_create(NULL);

  while( pcc_parse(ctx, NULL) ) {
  };

  pcc_destroy( ctx );

  return 0;
}
