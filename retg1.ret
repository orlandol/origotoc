
/*
 *  Retineo Gen 1 Compiler
 *  Copyright 2020 Orlando Llanes
 *
 *  License: MIT
 */
program retg1

/*
 *  Win32 type declaration section
 *  https://docs.microsoft.com/en-us/windows/win32/winprog/windows-data-types
 */

  type uint UINT

  type uint32 DWORD // type uint:32 DWORD
  type @DWORD LPDWORD

  const int FALSE 0
  const int TRUE 1
  type int BOOL

  type @ PVOID
  type @ LPVOID
  type /*const*/ @ LPCVOID

  type PVOID HANDLE

  type /*const*/ cstring LPCSTR

  // https://docs.microsoft.com/en-us/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)
  struct SECURITY_ATTRUBUTES
    DWORD nLength,
    LPVOID lpSecurityDescriptor,
    BOOL bInheritHandle
  end
  type @SECURITY_ATTRIBUTES PSECURITY_ATTRIBUTES
  type @SECURITY_ATTRIBUTES LPSECURITY_ATTRIBUTES

  // OVERLAPPED structure (minwinbase.h)
  // https://docs.microsoft.com/en-us/windows/win32/api/minwinbase/ns-minwinbase-overlapped
  struct OVERLAPPED
    ULONG_PTR Internal
    ULONG_PTR InternalHigh
    union
      struct
        DWORD Offset
        DWORD OffsetHigh
      end
      PVOID Pointer
    end
    HANDLE hEvent
  end
  type @OVERLAPPED LPOVERLAPPED

/*
 *  Win32 value declaration section
 */

  /*
   *  Generic file access flags
   *  General permissions that map to implementation defined permissions
   *  https://docs.microsoft.com/en-us/windows/win32/secauthz/generic-access-rights
   */

  // General read access
  const DWORD GENERIC_READ = 0b10000000000000000000000000000000

  // General write access
  const DWORD GENERIC_WRITE = 0b01000000000000000000000000000000

  // General execute access
  const DWORD GENERIC_EXECUTE = 0b00100000000000000000000000000000

  // All possible general access rights
  const DWORD GENERIC_ALL = 0b00010000000000000000000000000000

  /*
   *  Shared access mode flags
   *  https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea
   */
  // Allow file delete/rename
  const DWORD FILE_SHARE_DELETE = 0x00000004

  // Allow subsequent open for read access
  const DWORD FILE_SHARE_READ = 0x00000001

  // Allow subsequent open for write access
  const DWORD FILE_SHARE_WRITE = 0x00000002

  /*
   *  File disposition constants
   *  Defines actions to take when a file exists, or doesn't
   *  https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea
   */

  // Creates a new file, always.
  const DWORD CREATE_ALWAYS = 2

  // Creates a new file, only if it doesn't exist
  const DWORD CREATE_NEW = 1

  // Always opens a file
  const DWORD OPEN_ALWAYS = 4

  // Opens a file or device, only if it exists
  const DWORD OPEN_EXISTING = 3

  // Overwrites to zero bytes, only if it exists and GENERIC_WRITE is specified
  const DWORD TRUNCATE_EXISTING = 5

  /*
   *  File flags and attributes
   *  https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea
   */

  // Most common default for files
  const DWORD FILE_ATTRIBUTE_NORMAL = 0x80

  // File is used for temporary storage (delete on close?)
  const DWORD FILE_ATTRIBUTE_TEMPORARY = 0x100

  // File is to be deleted immediately after all of its handles are closed
  const DWORD FILE_FLAG_DELETE_ON_CLOSE = 0x04000000

/*
 *  Win32 function import section
 */

  /*
   *  CreateFileA function (fileapi.h)
   *  https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea
   */
  import HANDLE CreateFileA(
      LPCSTR lpFileName,
      DWORD dwDesiredAccess, dwSharedMode,
      LPSECURITY_ATTRIBUTES lpSecurityAttributes,
      DWORD dwCreationDisposition, dwFlagsAndAttributes,
      HANDLE hTemplateFile )
    from "kernel32.dll" as CreateFile

  /*
   *  ReadFile function (fileapi.h)
   *  https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-readfile
   */
  import BOOL ReadFile( HANDLE hFile, LPVOID lpBuffer,
      DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead,
      LPOVERLAPPED lpOverlapped )
    from "kernel32.dll"

  /*
   *  WriteFile function (fileapi.h)
   *  https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-writefile
   */
  import BOOL WriteFile( HANDLE hFile, LPCVOID lpBuffer,
      DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten,
      LPOVERLAPPED lpOverlapped )
    from "kernel32.dll"

  /*
   *  CloseHandle function (handleapi.h)
   *  https://docs.microsoft.com/en-us/windows/win32/api/handleapi/nf-handleapi-closehandle
   */
  import BOOL CloseHandle( HANDLE hObject )
    from "kernel32.dll"

/*
 *  RTL String object declarations
 */

  object string
  internal
    usize length
    char[length] data
  end

  cast char from string stringObj[ usize index ] implements string
    return stringObj.data[index]
  end

  func int strCompare( string leftStr, rightStr ) implements string
    var
      usize maxLen
      usize index
    end

    maxLen = leftStr.length
    if rightStr.length < maxLen
      then maxLen = rightStr.length

    if maxLen
      for index = 0 to (maxLen - 1)
        if leftStr.data[index] != rightStr.data[index]
          then break
      endfor

      return (leftStr.data[index] - rightStr.data[index])
    endif

    return -1
  end

  operator < ( string leftStr, rightStr ) implements string
    return strCompare(leftStr, rightStr) < 0
  end

  operator <= ( string leftStr, rightStr ) implements string
    return strCompare(leftStr, rightStr) <= 0
  end

  operator > ( string leftStr, rightStr ) implements string
    return strCompare(leftStr, rightStr) > 0
  end

  operator >= ( string leftStr, rightStr ) implements string
    return strCompare(leftStr, rightStr) >= 0
  end

  operator == ( string leftStr, rightStr ) implements string
    return strCompare(leftStr, rightStr) == 0
  end

  operator != ( string leftStr, rightStr ) implements string
    return strCompare(leftStr, rightStr) != 0
  end

  func string strAppend( string leftStr, rightStr ) implements string
    var
      @char[] newStr
      usize newLen
    end

    newLen = leftStr.length + rightStr.length

    newStr = realloc(result.data, (leftStr.length + rightStr.length) + 1)
    if @newStr == @null
      then return ""

    newStr.data[0..(leftStr.length-1)] = leftStr.data
    newStr.data[leftStr.length] = rightStr.data
    newStr.data[newLen] = 0

    return newStr
  end

/*
 *  RTL File I/O declarations
 */

  /* Base file object */
  object File
  end

  /* Base file interfaces */
  interface FileRead implements File
    method char ReadChar()
    method ufsize Read( @destBuffer, ufsize bytesToRead )
  end

  interface FileWrite implements File
    method bool WriteChar( char sourceChar )
    method ufsize Write( @sourceBuffer, ufsize bytesToWrite )
  end

  interface File inherits FileNoRead, FileNoWrite
    method Close()

    method ufsize Position()
    method bool Seek( ufsize newPosition )
    method bool SeekFwd( ufsize byAmount )
    method bool SeekRev( ufsize byAmount )
  end

  abstract FileRead inherits interface.FileRead
  end

  abstract FileWrite inherits interface.FileWrite
  end

  abstract File inherits interface.File
    method Close()
  end

  /* Disk file I/O object */
  object DiskFile inherits DiskFileRead, DiskFileWrite
    method bool Open( string fileName )
    method bool Modify( string fileName )
    method bool Create( string fileName )
  end

  /* Disk file I/O interfaces */
  interface DiskFileNoRead implements DiskFile inherits FileRead
  end

  interface DiskFileRead implements DiskFile inherits FileRead
  end

  interface DiskFileNoWrite implements DiskFile inherits FileWrite
  end

  interface DiskFileWrite implements DiskFile inherits FileWrite
  end

run
end

/*
 *  Implementation section
 */

/*
 *  RTL File I/O implementation
 */

  /* Disk file I/O implementation declarations
  object DiskFile
    HANDLE handle
  end

  /* Disk file I/O methods */
  method DiskFile.Close()
    if @handle
      CloseHandle( handle )
      @handle = @null
    endif
  end

  method bool DiskFile.Modify( string fileName )
    if @fileName && fileName[0]
      handle = CreateFile( fileName, GENERIC_WRITE,
          0, @null, CREATE_NEW, FILE_ATTRIBUTE_NORMAL, @null )
    endif
    return @handle != @null
  end

  method bool DiskFile.Create( string fileName )
    if @fileName && fileName[0]
      handle = CreateFile( fileName, GENERIC_WRITE,
          0, @null, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, @null )
    endif
    return @handle != @null
  end

  method bool DiskFile.Open( string fileName )
    if @fileName && fileName[0]
      handle = CreateFile( fileName, GENERIC_READ, 0, @null,
          OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, @null )
    endif
    return @handle != @null
  end

  method char DiskFile.ReadChar()
    return 0
  end

  method ufsize DiskFile.Read( @destBuffer, ufsize bytesToRead )
    return 0
  end

  method bool DiskFile.WriteChar( char sourceChar )
    return false
  end

  method ufsize DiskFile.Write( @sourceBuffer, ufsize bytesToWrite )
    return 0
  end

  method ufsize DiskFile.Position()
    return 0
  end

  method bool DiskFile.Seek( ufsize newPosition )
    return false
  end

  method bool DiskFile.SeekFwd( ufsize byAmount )
    return false
  end

  method bool DiskFile.SeekRev( ufsize byAmount )
    return false
  end
